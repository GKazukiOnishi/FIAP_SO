Exercícios memória

	3) Um sistema possui 6 molduras de páginas. O momento da carga, o número de acessos, o momento da última referência e os flags R e M para cada uma das páginas na memória são mostrados abaixo.
		Tabelinhas com dados e controle das páginas
		Decidir qual será substituída para cada algoritmo
	
		NUR - sai página com bits 0
		LFU - sai página com menos acessos
		FIFO - sai a página com menor valor de referência, entrou primeiro
		LRU - sai a página com menor valor de última referência, foi visitada há mais tempo
	
	5) Considere a seguinte sequência de referências de páginas:

	07647032747653063065

	Quantas faltas de página irão ocorrer para os algoritmos FIFO e LRU de substituição de páginas, considerando cinco molduras de páginas. Lembre-se que todas as molduras de página estão inicialmente vazias, de modo que a primeira página de cada moldura de página implicará em uma falta de página.

		a) FIFO
			
		M0: 0 -> 2
		M1: 7 -> 5
		M2: 6 -> 0
		M3: 4 -> 6
		M4: 3
			(vai tirando a página mais velha das molduras, ponteiro apontando para a primeira e andando para frente conforme tira alguma, quando chega no final volta o ponteiro pro começo -> bem simples de implementar e leve)
		Fp = 9
		
		b) LRU
			(vamos usar o alfabeto como sequência de tempo)
		M0: 0 (a)(f) -> 6 (l)
		M1: 7 (b)(e)(i)(k)
		M2: 6 (c) -> 2 (h) -> 3 (n)(q)(s)
		M3: 4 (d)(j) -> 0 (o)(r)
		M4: 3 (g) -> 5 (m)(p)(t)
			(percebemos que usa consideravelmente os recursos e também acaba falhando, tira página e precisa logo em seguida)
		Fp (falta de páginas) = 10
	
Algoritmo FIFO Circular (Clock)
	Páginas representadas em uma "circunferência"
	O ponteiro aponta para a primeira página, a página mais antiga
	Armazena também os bits R
	Se ela tiver sido usada, fica lá
	Vamos para a próxima
	bit R 0, nesse caso, parece que ninguém mais está usando, então tiramos da memória
	
	FIFO melhorado
	Toda hora que passamos um ponteiro pela página, resetamos o R para 0
	Nisso nunca acontece de todos os bits R ficarem 1 e o ponteiro dar loop infinito
	
	SO Unix / Linux usam ele

FIFO com Buffer de Páginas
	Usado no Windows
	Conceitualmente é a mesma ideia, mas é mais complexo de ser implementado
	
	FIFO de segunda chance
	
	Fila de páginas em utilização
	à medida que alguém precisa ser usado, empurra a fila
	As páginas vão indo pra frente conforme outras entram na fila
	Quando ela for a primeira da fila
	Toda hora que uma página é revisitada, ela volta pro final da fila
	Então a página que chega no início é porque não foi usada, então "acho" que não está sendo usada
	Nisso colocamos ela em outra fila auxiliar menor, uma lista de páginas livres (ainda na memória)
	Se em algum momento for acessada e ela estiver na fila de livres, ela volta para utilização
	
	Ideia de ser um pouco mais eficiente, mas é mais complexo porque tem duas listas
	Se uma página chegar no início da segunda fila, aí ela sai
	
	Vantagem é que se precisar ainda está na memória, a não ser que saia da segunda chance também
	
Segmentação - Outra técnica de implementação de memória virtual

	Pouco usada
	
	Do ponto de vista de programação faz sentido, já que o programa é divido em partes, segmentos
	Segmento de pilha, constantes, módulo principal, biblioteca de funções, funções de criptografia, periféricos
	
	O problema é que carregar um segmento na memória é um passo para trás, já que com paginação temos algo bem mais eficiente, pequenas porções de memória que são carregadas só quando precisa, se precisar, à medida que precisamos.
	
	Com segmento não, ele carrega o segmento inteiro, carrega o módulo de criptografia inteira, mas será que precisa disso tudo? geralmente não
	Então acaba usando mais memória, perde tempo carregando muita coisa que não vai usar em E/S, e nem usa tudo no final geralmente
	
	Por isso a maioria dos SOs não implementa
	
	Aplicações de segurança pode usar, já que acaba sendo um primeiro nível de segurança
	Já que com isso o SO garante que uma aplicação não invada o espaço de endereçamento de outro
	Então a memória fica bem mais protegida
	
	O problema é que não é muito performático
	Os sistemas que usam então trabalham com paginação dentro do segmento
	
Memória virtual tem mais de 30 anos
Com o tempo os algoritmos vem melhorando
Tamanho da página vem sendo ajustada de acordo com as aplicações

RAM Disk -> vem sendo pesquisada, guardar as páginas em uma RAM chamada RAM DISC

RAM Disk x SSD x HDD (Hard disk drive) RAID 5
RAM Disk ganhou de todas em usos Sequenciais, Random(512K), Random(4K) e Random(4K QD32)
Ganhou de forma bem significativa
Tanto leitura quanto escrita
Mas é claro, é muito caro, uma disco de RAM inteira

7) Tem-se observado que o número de instruções executadas entre faltas de páginas é diretamente proporcional ao número de molduras de página alocadas para um programa. Se a memória disponível for duplicada, o intervalo médio entre faltas de página também será duplicado. Suponha um sistema com um único processador no qual uma instrução normal leve 2 s (microssegundo), mas se uma falta de página ocorrer, ela levará 2.002 s, isto é, 2 ms (milissegundo) para tratar a falta de página. Se um programa leva 40 s para ser executado, período em que ele terá 10.000 faltas de página, quanto tempo ele levaria para ser executado se existisse duas vezes mais memória disponível? Considere o processo em questão como sendo estritamente CPU-bound.

	Difícil medir com E/S porque o disco depende de muitas coisas para saber quanto tempo vai demorar para ler e escrever
	
	Situação 1)
	tempoExeApp = tempoExeInstrucoes + tempoTratamentoFaltaDePagina
	40s = tei + 10.000*2ms
	40s = tei + 20.000ms
	40s = tei + 10*10^3*2*10^-3
	40s = tei + 20s
	tei = 20s
	
	Situação 2)
	São as mesmas instruções, então continua demorando 20s
	tea = 20s + 5.000*2ms
	Situação com 2xRAM
	então temos só 5.000 faltas de páginas
	tea = 20s + 5*10^3*2*10^-3
	tea = 20s + 10s
	tea = 30
	
	Então colocar 2x mais memória RAM não reduz pela metade o tempo de execução
	Tem um custo fixo, o tempo de execução das instruções no processador